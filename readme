*****PYTHON EXPLAINED*****

Pour commencer, mon programme demande au user via une commande input dans le terminal quel Scénario jouer (Preset).
Ensuite, selon le scénario choisi, une valeur de base est attribué a mon nombre d'ascenseur et mon nombre d'étage
ainsi que la direction (up/down/null) et l'étage de mes ascenseurs. 


Mon nombre d'ascenseur est envoyé dans ma colonne dans une petite for loop qui créer un objet ascenseur selon le 
nombre d'ascenseur choisi plus haut (si mon nombre d'ascenseur est de 2, alors 2 objets sera créer) et les enverront
dans une liste d'ascenseur. Le même principe est utilisé pour ma floorsList, mais plutôt que de contenir des objets
elle contiendra un index qui contient sa valeur (si i = 1, mon étage sera le 1er).

La demande d'étage preset plus haut ainsi que la direction demandé sera envoyé dans ma fonction "requestElevator" 
pour y être storé et envoyé directement à ma fonction "findElevator". 

Ma fonction "FindElevator" va calculer un "score" pour déterminer quel ascenseur est le mieux adapté pour la requête.
Elle priorise les ascenseurs en marches (up/down) et qui vont dans la même direction que mon user tout en y intégrant
une "différence d'étage" entre mon ascenseur et l'user en valeur absolue pour envoyer celle qui est la plus proche
lorsque 2 ascenseurs remplissent la même condition. À chaque condition, le score monte de 100 pour prévenir un ascenseur
moins adapté de scorer plus bas qu'un ascenseur moins adapté lorsque le calcul de différence d'étage est additioner au
score.
Une fonction de tri triera ma liste d'ascenseur par rapport a leur score du plus petit au plus grand, puisque mon 
"bestElevator" sera toujours l'ascenseur à l'index 0 de la liste. Le "bestElevator" sera envoyé à ma fonction "move" 
via la méthode "elevator.move" dans ma classe Elevator.

La fonction "Move" détermine si l'ascenseur doit monter ou descendre en comparant son "currentFloor" à l'étage demandé.
Si le "currentFloor" est plus petit que l'étage demandé, alors il montera et vice versa tant que le "currentFloor" 
ne sera pas égal a l'étage demandé (while Loop). Une fois arrivé a l'étage de sa requête, l'ascenseur s'arrêtera
et ouvrira ses portes pour le user.

La function "RequestFloor" est callé avec le "bestElevator" et la destination comme argument tout de suite après
que ma fonction move soit terminé. La function "requestFloor" store la destination et renvoie directement l'information
ainsi que le "bestElevator" via la méthode "moveD". 

La fonction "moveD" fait exactement la même chose que la fonction move, la seule différence majeur est le print
(donc détermine dans quel direction aller via un calcul de différence d'étage, etc...)
Arrivé a destination, l'ascenseur s'arrête et fermes les portes, prêt pour la prochaine requête. 

Une petite fonction "Retry" demandera via un input si on souhaites relancer le programme pour tester un scénario 
différent ou non. Si on relance le programme, toutes les variables seront réinitialiser et remplacer par de nouvelles
valeur ; celles du scénario sélectionner. Elle relancera les fonctions de la même manière que précédemment.
Si au contraire, on souhaite sortir du programme avec la petite commande "n", alors le programme se termine avec un 
petit print qui confirme votre choix ;). 